%% For double-blind review submission, w/o CCS and ACM Reference (max submission space)
\documentclass[acmsmall,review,anonymous]{acmart}\settopmatter{printfolios=true,printccs=false,printacmref=false}

\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations



%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption
\usepackage{xspace}

\usepackage{minted}
\setminted{fontsize=\footnotesize,
  escapeinside=\#\#,
  mathescape=true}
\setmintedinline{fontsize=\small,
  escapeinside=\&\&,
  mathescape=true}
\newcommand{\inline}[1]{\hspace*{-3pt}\mintinline{haskell}{#1}\hspace*{-3pt}}

%% Some useful macros
\newcommand{\system}{\textsc{SensCheck}\xspace}
\newcommand{\quickcheck}{\textsc{QuickCheck}\xspace}

\newcommand{\mynote}[2]
    {{\color{red} \fbox{\bfseries\sffamily\scriptsize#1}
    {\small$\blacktriangleright$\textsf{\emph{#2}}$\blacktriangleleft$}}~}
%\newcommand{\mynote}[2]{}
\newcommand{\todo}[1]{\mynote{TODO}{#1}}


\begin{document}

\title{\system: \quickcheck for Function Sensitivity}

\begin{abstract}
Text of abstract \ldots.
\end{abstract}
\maketitle


\section{Introduction}


\section{Background: Function Sensitivity and Differential Privacy}

\todo{function sensitivity}

\todo{sensitivity as part of differential privacy}

\section{\system by Example}

Suppose that we need to test a Solo function that adds two sensitive doubles.
The result should be another sensitive double with the sensitivities added.


To express that with Solo you may create the following function:
\begin{minted}{haskell}
solo_plus :: SDouble Diff s1 -> SDouble Diff s2 -> SDouble Diff (s1 +++ s2)
solo_plus a b = D_UNSAFE $ unsafe_plus (unSDouble a) (unSDouble b)
\end{minted}

To validate that the upper bound of that assertion is true with SensCheck you can create the following test:
\begin{minted}{haskell}
{-# LANGUAGE TemplateHaskell #-}
import DistanceFunctions
import Sensitivity
import Utils
import TH (genMainQuickCheck)
import Test.QuickCheck (quickCheck, withMaxSuccess)

$(genMainQuickCheck "tests" ['solo_plus])

main :: IO ()
main = tests
\end{minted}

Running the test case shows the following output:

\todo{Show output}

genMainQuickCheck genererates a quickcheck property and a main function that invokes that property.
By invoking ghc with -ddump-splices you will see the generated output which will appear similar to the following:
\begin{minted}{haskell}
solo_plus_prop input1_a2zn input1_a2zq input2_a2zo input2_a2zr
  = let
      distance_a2zp = (distance input1_a2zn) input2_a2zo
      distance_a2zs = (distance input1_a2zq) input2_a2zr
      dout_a2zt
        = (distance ((solo_plus input1_a2zn) input1_a2zq))
            ((solo_plus input2_a2zo) input2_a2zr)
    in (dout <= ((distance_a2zp + distance_a2zs) + 1.0e-8))
\end{minted}

\todo{This is the ``tutorial section''}

\section{\system Implementation}

\todo{This section describes the implementation (how the tests are generated)}

\section{\system Metatheory}

\todo{This section proves that the tests correspond to the property encoded in the sensitivity type annotations}

\section{Evaluation}

\todo{This section should say how well it works and how long it takes; how many bugs it finds}


%% Appendix
\appendix
\section{Appendix}

Text of appendix \ldots

\end{document}
